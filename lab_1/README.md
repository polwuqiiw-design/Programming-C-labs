# Тема: Указатели  
## Задача 1 – упражнения с malloc и сложными однострочными выражениями в C с присваиваниями внутри  

### Постановка задачи  
Внутри функции int main(void) { /*...*/ } определите указатель:
double ***pointer = NULL;
Инициализируйте этот указатель адресом другого указателя типа double **, который указывает, в свою очередь, на
переменную double. Используйте pointer для записи и чтения в эту переменную значения 2.
При этом выполните следующее: - Используйте функции типа *alloc(...) для выделения оперативной памяти под
динамические объекты; - Запишите и выведите число 2 на экран, используя указатель double ***pointer = NULL;;
- Используйте функцию free(...) для освобождения оперативной памяти, выделенной под динамические объекты.
- Не используйте никаких идентификаторов переменных, кроме pointer.

---

### Математическая модель  
- Трёхуровневая система указателей:  
  - `pointer` → `double**` → `double*` → `double`.  
- В памяти хранится значение `2.0`.  
- Доступ к переменной и её модификация выполняется исключительно через `pointer`.  

---

### Список идентификаторов  

| Имя переменной | Тип данных  | Описание |
|----------------|-------------|----------|
| pointer        | double***   | Указатель на указатель на указатель на double |

### Код программы  

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    double ***pointer = NULL;

    pointer = (double ***)malloc(sizeof(double **));
    *pointer = (double **)malloc(sizeof(double *));
    **pointer = (double *)malloc(sizeof(double));

    ***pointer = 2.0;

    printf("Значение: %.1f\n", ***pointer);

    free(**pointer);
    free(*pointer);
    free(pointer);

    return 0;
}
```

### Результаты работы программы   
![result 1](./img/task1.png)
---

## Задача 2 - итерация массива с помощью арифметики указателей

### Постановка задачи
Напишите программу, которая создает одномерный динамический массив из чисел с плавающей точкой двойной точности, заполняет его значениями с клавиатуры и выводит все элементы массива, используя арифметику указателей
(оператор +), а не оператор доступа к элементам массива [].

### Математическая модель  
- Создаётся одномерный динамический массив элементов типа `double`.  
- Доступ к элементам массива осуществляется через арифметику указателей:  
  - `(arr + i)` — адрес элемента,  
  - `*(arr + i)` — значение элемента.  
- Таким образом, обход массива происходит без использования синтаксиса `arr[i]`.  

### Список идентификаторов  

| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| arr            | double*    | Указатель на первый элемент динамического массива |
| n              | int        | Количество элементов массива |
| i              | int        | Счётчик цикла |

### Код программы  

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int n;
    printf("Введите количество элементов массива: ");
    scanf("%d", &n);

    double *arr = (double *)malloc(n * sizeof(double));
    if (arr == NULL) {
        printf("Ошибка выделения памяти!\n");
        return 1;
    }

    printf("Введите %d элементов массива:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%lf", (arr + i));
    }

    printf("Элементы массива:\n");
    for (int i = 0; i < n; i++) {
        printf("%.2f ", *(arr + i));
    }
    printf("\n");

    free(arr);

    return 0;
}
```

### Результаты работы программы
![result 2](./img/task2.png)
---

## Задача 3 - динамический 2D массив

### Постановка задачи 
Выделите память под двумерный динамический массив двумя способами:
1. Классический способ: выделите память для массива указателей на строки и отдельно для каждой строки в
цикле. Это позволит гибко управлять памятью, но при этом каждая строка будет находиться в отдельной части
памяти.
2. Непрерывный способ (contiguous memory allocation): выделите память для всего массива одним вызовом
malloc, что позволит разместить весь массив в непрерывном блоке памяти, улучшая производительность и
снижая риск внешней фрагментации памяти.
После выполнения программы обязательно корректно освободите всю выделенную оперативную память с помощью
free().
Оба метода имеют свои преимущества и недостатки. При непрерывном выделении (contiguous allocation) вся память
выделяется в одном блоке, что уменьшает вероятность фрагментации, но может усложнить управление при необходимости изменения размеров массива.

### Математическая модель  
- Массив имеет форму `n x m`.  
- В классическом подходе создаётся массив указателей на строки (`int**`), каждая строка выделяется отдельно.  
- В непрерывном подходе создаётся один блок памяти размером `n*m`, а доступ к элементу осуществляется по формуле: arr[i][j] ↔ *(arr + i * m + j)

### Список идентификаторов  
| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| n              | int        | Количество строк |
| m              | int        | Количество столбцов |
| arr1           | int**      | Двумерный массив (классический способ) |
| arr2           | int*       | Двумерный массив (непрерывный способ) |
| i, j           | int        | Счётчики циклов |


### Код программы  

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
  int n, m;
  printf("Введите количество строк и столбцов: ");
  scanf("%d %d", &n, &m);

  int **arr1 = (int **)malloc(n * sizeof(int *));
  for (int i = 0; i < n; i++) {
      arr1[i] = (int *)malloc(m * sizeof(int));
  }

  printf("Введите элементы массива (классический способ):\n");
  for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
          scanf("%d", &arr1[i][j]);
      }
  }

  printf("Вывод массива (классический способ):\n");
  for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
          printf("%d ", arr1[i][j]);
      }
      printf("\n");
  }

  int *arr2 = (int *)malloc(n * m * sizeof(int));

  printf("Введите элементы массива (непрерывный способ):\n");
  for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
          scanf("%d", (arr2 + i * m + j));
      }
  }

  printf("Вывод массива (непрерывный способ):\n");
  for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
          printf("%d ", *(arr2 + i * m + j));
      }
      printf("\n");
  }

  for (int i = 0; i < n; i++) {
      free(arr1[i]);
  }
  free(arr1);
  free(arr2);

  return 0;
}
```

### Результаты работы программы
![result 3](./img/task3.png)
---

## Задача 4 - поменять местами два числа через указатели

### Постановка задачи 
Написать программу, которая использует функцию для обмена значениями двух переменных через указатели

### Математическая модель 
- Имеются две переменные `a` и `b`.  
- Через функцию `swap(int *x, int *y)` выполняется обмен значениями:  
  - временно сохраняем значение `*x` в переменную `temp`,  
  - присваиваем `*x = *y`,  
  - присваиваем `*y = temp`.  
- Таким образом, значения переменных меняются местами без прямого использования их имён в теле программы.  

### Список идентификаторов  

| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| a              | int        | Первая переменная |
| b              | int        | Вторая переменная |
| temp           | int        | Временное хранилище при обмене |
| swap           | функция    | Функция для обмена значениями через указатели |

### Код программы  

```c
#include <stdio.h>

void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main(void) {
    int a, b;
    printf("Введите два числа: ");
    scanf("%d %d", &a, &b);

    printf("До обмена: a = %d, b = %d\n", a, b);

    swap(&a, &b);

    printf("После обмена: a = %d, b = %d\n", a, b);

    return 0;
}
```

### Результаты работы программы
![result 4](./img/task4.png) 
---

## Задача 5 - поиск максимального элемента массива с помощью указателей

### Постановка задачи
Создать функцию, которая принимает массив целых чисел и его размер, а затем возвращает указатель на максимальный элемент массива.

### Математическая модель
- Задаётся массив `arr` размером `n`.  
- Используется указатель для обхода массива.  
- При сравнении элементов сохраняется адрес текущего максимального значения.  
- Функция возвращает указатель на элемент с максимальным значением.  

### Список идентификаторов  

| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| arr            | int*       | Указатель на массив целых чисел |
| n              | int        | Размер массива |
| max_ptr        | int*       | Указатель на текущий максимальный элемент |
| i              | int        | Счётчик цикла |
| find_max       | функция    | Функция поиска максимального элемента массива |

### Код программы  

```c
#include <stdio.h>
#include <stdlib.h>

int* find_max(int *arr, int n) {
    int *max_ptr = arr; 
    for (int i = 1; i < n; i++) {
        if (*(arr + i) > *max_ptr) {
            max_ptr = arr + i;
        }
    }
    return max_ptr;
}

int main(void) {
    int n;
    printf("Введите количество элементов массива: ");
    scanf("%d", &n);

    int *arr = (int *)malloc(n * sizeof(int));

    printf("Введите %d элементов массива:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", (arr + i));
    }

    int *max_ptr = find_max(arr, n);

    printf("Максимальный элемент массива: %d\n", *max_ptr);

    free(arr);
    return 0;
}
```

### Результаты работы программы
![result 5](./img/task5.png) 
---

## Задача 6 – реверс массива через указатели  

### Постановка задачи  
Реализовать функцию, которая переворачивает массив целых чисел, используя указатели для перемещения по элементам.  

### Математическая модель  
- Имеется массив `arr` длиной `n`.  
- Используются два указателя:  
  - `left` — указывает на первый элемент,  
  - `right` — указывает на последний элемент.  
- Меняем значения, на которые указывают `left` и `right`, затем сдвигаем указатели навстречу друг другу.  
- Алгоритм завершается, когда `left >= right`.  

### Список идентификаторов  

| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| arr            | int*       | Указатель на массив |
| n              | int        | Размер массива |
| left, right    | int*       | Указатели на левый и правый элемент |
| temp           | int        | Временное хранилище для обмена |
| reverse        | функция    | Функция реверса массива |

### Код программы  

```c
#include <stdio.h>
#include <stdlib.h>

void reverse(int *arr, int n) {
    int *left = arr;
    int *right = arr + n - 1;

    while (left < right) {
        int temp = *left;
        *left = *right;
        *right = temp;

        left++;
        right--;
    }
}

int main(void) {
    int n;
    printf("Введите количество элементов массива: ");
    scanf("%d", &n);

    int *arr = (int *)malloc(n * sizeof(int));

    printf("Введите %d элементов массива:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", (arr + i));
    }

    reverse(arr, n);

    printf("Массив после реверса:\n");
    for (int i = 0; i < n; i++) {
        printf("%d ", *(arr + i));
    }
    printf("\n");

    free(arr);
    return 0;
}
```

### Результаты работы программы
![result 6](./img/task6.png) 
--- 

## Задача 7 – поиск подстроки в строке через указатели  

### Постановка задачи  
Реализовать функцию, которая находит первое вхождение одной строки в другую, используя указатели вместо индексов для доступа к символам строки.  

### Математическая модель  
- Даны две строки:  
  - `str` — исходная строка,  
  - `substr` — подстрока.  
- Для поиска используется перебор:  
  - выбираем позицию в `str`,  
  - проверяем совпадение символов с `substr` с помощью указателей.  
- Если найдено совпадение — возвращается указатель на начало подстроки в строке.  
- Если совпадения нет — возвращается `NULL`.  

### Список идентификаторов  

| Имя переменной | Тип данных | Описание |
|----------------|------------|----------|
| str            | char*      | Указатель на исходную строку |
| substr         | char*      | Указатель на подстроку |
| p1, p2         | char*      | Указатели для обхода строки и подстроки |
| find_substr    | функция    | Функция поиска подстроки в строке |

### Код программы  

```c
#include <stdio.h>

char* find_substr(const char *str, const char *substr) {
    if (!*substr) return (char*)str; 

    for (const char *p = str; *p != '\0'; p++) {
        const char *p1 = p;
        const char *p2 = substr;

        while (*p1 && *p2 && (*p1 == *p2)) {
            p1++;
            p2++;
        }

        if (*p2 == '\0') {
            return (char*)p; 
        }
    }
    return NULL;
}

int main(void) {
    char str[100], substr[100];
    printf("Введите строку: ");
    fgets(str, sizeof(str), stdin);

    printf("Введите подстроку: ");
    fgets(substr, sizeof(substr), stdin);

    for (char *p = str; *p; p++) {
        if (*p == '\n') { *p = '\0'; break; }
    }
    for (char *p = substr; *p; p++) {
        if (*p == '\n') { *p = '\0'; break; }
    }

    char *res = find_substr(str, substr);
    if (res) {
        printf("Подстрока найдена: \"%s\"\n", res);
    } else {
        printf("Подстрока не найдена.\n");
    }

    return 0;
}
```

### Результаты работы программы
![result 7](./img/task7.png) 
---

### Информация о студенте  
Полторацкая Анастасия, 1 курс, группа `1об_ПОО/25`
